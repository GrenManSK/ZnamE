# v1.2.0-alpha+build.20230429.122048

- [#12](https://github.com/GrenManSK/ZnamE/issues/12) - Fixed bug
- Added dotenv

```diff
edupage.py
@@ -441,25 +441,24 @@
  sys.exit(1)
- 
 %0A    try:%0A  
@@ -702,17 +702,16 @@
 .exit(1)
- 
 %0A    log
@@ -800,16 +800,99 @@
 -%M-%S")
+
+    with open('.env', 'w') as dotenv:
+        dotenv.write(f'DATELOG={datelog}\n')
 %0A%0A    de
@@ -4947,94 +4947,8 @@
 ))%0A%0A
-    "Printing the unlisted modules + importing others dependencies using chocolatey"
-
-
     
@@ -5514,3526 +5514,634 @@
     
-class configNoOption(Exception):
-        pass
-
-    class argLanguageError(Exception):
-        pass
-
-    class argIntroError(Exception):
-        pass
-
-    class argInactiveLimitError(Exception):
-        pass
-
-    class argMusicListError(Exception):
-        pass
-
-    class argMusicError(Exception):
-        pass
-
-    class argEnviromentError(Exception):
-        pass
-
-    class argWaifuError(Exception):
-        pass
-
-    class argNekoError(Exception):
-        pass
-
-    class argGameError(Exception):
-        pass
-
-    allerror = []
-    for name, obj in inspect.getmembers(sys.modules[__name__]):
-        if inspect.isclass(obj):
-            allerror.append(obj.__name__)
-
-    if __name__ == '__main__':
-        for i in range(0, len(allerror)-1):
-            printnlog(allerror[i], end=', ')
-        printnlog(allerror[len(allerror)-1])
-
-    def error_log(line: int) -%3E None:
-        """
-        It writes the error to a file and prints it to the console
-
-        :param line: The line number of the error
-        """
-        with open('error.log', 'a', encoding='utf-8') as errorfile:
-            exc_type, exc_obj, exc_tb = sys.exc_info()
-            exc_type = exc_type.__qualname__
-            fname: str = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
-            errorfile.write(
-                f'Type of error: {str(exc_type)} %7C Comment: {str(exc_obj)} %7C In file: {str(fname)} %7C On line: {str(line)}\n')
-        printnlog(
-            f'Type of error: {str(exc_type)} %7C Comment: {str(exc_obj)} %7C In file: {str(fname)} %7C On line: {str(line)}')
-
-    def error_get(errors, line: list) -%3E None:
-        """
-        The error_get function is used to raise the errors that are found in the error_log function.
-            The error_get function takes two arguments:
-                1) errors - a list of exceptions that were raised by the code being tested.
-                2) line - a list of strings containing information about each exception raised.
-
-        :param errors: Store the errors that are raised by the function
-        :param line: list: Store the line numbers of the errors
-        :return: The error code and the line number of the error
-        """
-
-        for times, error in enumerate(errors.exceptions):
-            try:
-                raise eval(
-                    error.with_traceback.__qualname__.split('.')[0])(error)
-            except eval(error.with_traceback.__qualname__.split('.')[0]):
-                if len(line) == 1 and times %3E 0:
-                    error_log(line[0])
-                else:
-                    error_log(line[times])
-
-    def get_line_number(goback: int = 0, relative_frame: int = 1) -%3E int:
-        """
-        The get_line_number function returns the line number of the caller.
-
-            The get_line_number function is a helper function that returns the line number of 
-            where it was called from. This can be useful for debugging purposes, or to help 
-            identify where an error occurred in your code. It also allows you to go back a few lines if needed, which can be helpful when using this function inside loops and other functions that may have multiple calls on one line (such as list comprehensions).
-
-        :param goback: int: Go back a certain number of lines in the stackconfig.
-        :param relative_frame: int: Specify the frame in the stack to get the line number from
-        :return: The line number of the function call
-        """
-        return int(inspect.stack()[relative_frame][0].f_lineno)-int(goback
+from essentials.exceptions import argGameError, argEnviromentError, argInactiveLimitError, argIntroError, argLanguageError, argMusicError, argMusicListError, argNekoError, argWaifuError, configNoOption
+    from essentials.exceptions import error_get
+    from essentials.system_info import get_line_number
+    allerror = []
+    for name, obj in inspect.getmembers(sys.modules[__name__]):
+        if inspect.isclass(obj):
+            allerror.append(obj.__name__)
+
+    if __name__ == '__main__':
+        for i in range(0, len(allerror)-1):
+            printnlog(allerror[i], end=', ')
+        printnlog(allerror[len(allerror)-1]
 )%0A%0A 
@@ -7741,36 +7741,61 @@
 (1)%0A
-        printnlog('\nDone\n'
+
+    logger.stay(printnlog('\nDone\n', toprint=False)
 )%0A%0A 
@@ -8186,24 +8186,16 @@
 ged to.%0A
-        
 %0A       
@@ -8433,32 +8433,54 @@
  it%0A        """%0A
+        global config
+
         config =
@@ -8792,6133 +8792,423 @@
     
-return info
-
-    if __name__ == '__main__':
-        from essentials.arguments import arguments
-        parser, music, language, UNSPECIFIED = arguments(config)
-        args = parser.parse_args()
-        hexnumber: list[str] = ['0', '1', '2', '3', '4', '5', '6',
-                                '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']
-        logger.stay(printnlog("Checking config correctness", toprint=False))
-        if not config['basic info']['enviroment'].split(' ')[0][0] in hexnumber:
-            error_get(ExceptionGroup('', [argEnviromentError('Wrong choice \'basic info\' =%3E enviroment first character'), ValueError(
-                f'Not allowed character %7C Allowed: {hexnumber}')]), [get_line_number()])
-            sys.exit(1)
-        elif not config['basic info']['enviroment'].split(' ')[0][1] in hexnumber:
-            error_get(ExceptionGroup('', [argEnviromentError('Wrong choice \'basic info\' =%3E enviroment second character'), ValueError(
-                f'Not allowed character %7C Allowed: {hexnumber}')]), [get_line_number()])
-            sys.exit(1)
-        else:
-            printnlog('basic info =%3E enviroment')
-        try:
-            int(config['basic info']['inactivelimit'])
-            printnlog('basic info =%3E inactivelimit')
-        except ValueError:
-            error_get(ExceptionGroup('', [argInactiveLimitError(
-                'Wrong choice in \'basic info\' =%3E inactivelimit'), ValueError('take only numbers')]), [get_line_number()])
-            sys.exit(1)
-        if not config['basic info']['intro'] in [True, False]:
-            error_get(ExceptionGroup('', [argIntroError('Wrong choice in \'basic info\' =%3E intro'), ValueError(
-                'Only \'True\' or \'False\'')]), [get_line_number()])
-            sys.exit(1)
-        else:
-            printnlog('basic info =%3E intro')
-        if config['basic info']['music'].split(' ')[0] == 'enable':
-            args.music = config['basic info']['musicnumber']
-            printnlog('basic info =%3E music')
-        elif config['basic info']['music'].split(' ')[0] == 'disable':
-            printnlog('basic info =%3E music')
-            pass
-        else:
-            error_get(ExceptionGroup('', [argMusicError('Wrong choice in \'basic info\' =%3E music'), ValueError(
-                'Only \'enable\' or \'disable\'')]), [get_line_number()])
-            sys.exit(1)
-        if not config['waifu settings']['type'].split(' ')[0] in ['sfw', 'nsfw']:
-            error_get(ExceptionGroup('', [argWaifuError('Wrong choice in \'waifu settings\' =%3E type'), ValueError(
-                'Only \'sfw\' or \'nsfw\'')]), [get_line_number()])
-            sys.exit(1)
-        else:
-            printnlog('waifu settings =%3E type')
-        if config['waifu settings']['type'] == 'sfw':
-            category: list[str] = ["waifu", "neko", "shinobu", "megumin", "bully", "cuddle", "cry", "hug", "awoo", "kiss", "lick", "pat", "smug", "bonk", "yeet",
-                                   "blush", "smile", "wave", "highfive", "handhold", "nom", "bite", "glomp", "slap", "kill", "kick", "happy", "wink", "poke", "dance", "cringe"]
-            if not config['waifu settings']['category'].split(' ')[0] in category:
-                error_get(ExceptionGroup('', [argWaifuError('Wrong choice in \'waifu settings\' =%3E category'), ValueError(
-                    'Use \'waifu\' and see option in setup function')]), [get_line_number()])
-                sys.exit(1)
-            else:
-                printnlog('waifu settings =%3E category')
-        elif config['waifu settings']['type'] == 'nsfw':
-            category: list[str] = ['waifu', 'neko', 'trap', 'blowjob']
-            if not config['waifu settings']['category'].split(' ')[0] in category:
-                error_get(ExceptionGroup('', [argWaifuError('Wrong choice in \'waifu settings\' =%3E category'), ValueError(
-                    'Use \'waifu\' and see option in setup function')]), [get_line_number()])
-                sys.exit(1)
-            else:
-                printnlog('waifu settings =%3E category')
-        server: list[str] = ['nekos.best', 'waifu.pics', 'kyoko', 'nekos_api']
-        if not config['neko settings']['server'] in server:
-            error_get(ExceptionGroup('', [argNekoError('Wrong choice in \'neko settings\' =%3E server'), ValueError(
-                f'Only take {str(server)}')]), [get_line_number()])
-            sys.exit(1)
-        else:
-            printnlog('neko settings =%3E server')
-        try:
-            int(config['game settings']['goal_score'])
-        except ValueError:
-            error_get(ExceptionGroup('', [argGameError('Wrong choice in \'game settings\' =%3E goal_score'), ValueError(
-                'take only numbers')]), [get_line_number()])
-            sys.exit(1)
-        try:
-            if 10 %3C= int(config['game settings']['goal_score']):
-                printnlog('game settings =%3E goal_score')
-            else:
-                raise ValueError
-        except ValueError:
-            error_get(ExceptionGroup('', [argGameError(
-                'Wrong choice in \'game settings\' =%3E goal_score'), ValueError('minimum is 10')]), [get_line_number()])
-            sys.exit(1)
-        try:
-            float(config['game settings']['computer_power'])
-            printnlog('game settings =%3E computer_power')
-        except ValueError:
-            error_get(ExceptionGroup('', [argGameError('Wrong choice in \'game settings\' =%3E computer_power'), ValueError(
-                'take only numbers')]), [get_line_number()])
-            sys.exit(1)
-        if config['basic info']['music'] == 'enable':
-            musiclimittext: bool = False
-            while len(music) %3C int(config['basic info']['musicnumber']):
-                if not musiclimittext:
-                    typewriter(printnlog('basic info =%3E musicnumber; you have exceeded the limit by ' +
-                                         str(int(config['basic info']['musicnumber']) - len(music)), toprint=False))
-                    musiclimittext: bool = True
-                set_config('basic info', 'musicnumber', int(args.music)-1)
-                args.music = str(int(args.music)-1
+config = yaml.safe_load(open('config.yml', 'r'))
+        return info
+
+    if __name__ == '__main__':
+        from essentials.arguments import arguments, check_correctness
+        server: list[str] = ['nekos.best', 'waifu.pics', 'kyoko', 'nekos_api']
+        parser, music, language, UNSPECIFIED = arguments(config)
+        args = parser.parse_args()
+        check_correctness(args, config, logger, music, set_config
 )%0A%0A 
@@ -12760,16 +12760,33 @@
 adline3'
+, 'python-dotenv'
 }%0A      
@@ -15261,18121 +15261,1012 @@
     
-
-    class installing_carousel:
-        def __init__(self, package: str, comment: str = 'Installing', bar: bool = False, move_by_command: bool = False):
-            self.package = package
-            self.comment = comment
-            self.bar = bar
-            self.move_by_command = move_by_command
-            self._move = 0
-            self.id = mathematical.get_id()
-
-        def start(self):
-            """
-            The start function is the main function of the class. It starts a thread that runs init()
-
-            :param self: Represent the instance of the class
-            :return: Nothing, so the return statement is never reached
-            """
-
-            Thread(target=self.init).start()
-
-        def pause(self):
-            """
-            The pause function is used to pause the installation of a package.
-
-            :param self: Represent the instance of the class
-            :return: Nothing, it just creates a file
-            """
-            open(f"INSTALL_PAUSE{self.id}", 'x')
-
-        def unpause(self):
-            open(f"INSTALL_UNPAUSE{self.id}", 'x')
-
-        def stop(self, mode='s'):
-            """
-            The stop function is called when the user wants to stop the installation.
-
-            :param self: Represent the instance of the class
-            :param mode: Determine what file is created
-            :return: The name of the file that is created
-            """
-            if mode == 's':
-                open(f"INSTALL_DONE{self.id}", 'x')
-            if mode == 'e':
-                open(f"INSTALL_ERROR{self.id}", 'x')
-            if mode == 'ali':
-                open(f"INSTALL_ALINST{self.id}", 'x')
-
-        def move(self):
-            self._move += 1
-
-        def init(self):
-            """
-            The init function is used to initialize the package installation.
-            It will print a loading bar until it finds an INSTALL_DONE, INSTALL_ERROR or 
-            INSTALL_ALINST file in the current directory. If it finds an INSTALL_DONE file, 
-            it will print DONE after the package name and if it finds an INSTALL_ERROR file, 
-            it will print ERROR after the package name. If it finds an INSTALL_ALINST file, 
-            it will print ALREADY INSTALLED after the package name.
-
-            :param self: Represent the instance of the class
-            :return: Nothing, so the return statement is not needed
-            """
-            error = False
-            alinst = False
-            number = 0
-            char = ['%7C', '/', '-', '\\']
-            while True:
-                if os.path.isfile(f'INSTALL_DONE{self.id}'):
-                    break
-                if os.path.isfile(f'INSTALL_ERROR{self.id}'):
-                    error = True
-                    break
-                if os.path.isfile(f'INSTALL_ALINST{self.id}'):
-                    alinst = True
-                    break
-                if os.path.isfile(f'INSTALL_PAUSE{self.id}'):
-                    if not self.bar:
-                        print(
-                            '                                            ', end='\r')
-                    if self.bar:
-                        tqdm.write(
-                            '                                            ')
-                    os.remove(f'INSTALL_PAUSE{self.id}')
-                    while not os.path.isfile(f'INSTALL_UNPAUSE{self.id}'):
-                        sleep(0.1)
-                    os.remove(f'INSTALL_UNPAUSE{self.id}')
-                if not self.bar:
-                    print(
-                        f'{self.comment} {self.package} {char[number]}               ', end='\r')
-                if self.bar:
-                    tqdm.write(
-                        f'{self.comment} {self.package} {char[number]}               ')
-                if not self.move_by_command or self._move != 0 and self.move_by_command:
-                    number += 1
-                    if self.move_by_command:
-                        self._move -= 1
-                if number %3E= len(char):
-                    number = 0
-                sleep(0.1)
-            if error:
-                if not self.bar:
-                    print(f'{self.comment} {self.package} ERROR             ')
-                if self.bar:
-                    tqdm.write(f'{self.comment} {self.package} ERROR             ')
-            elif alinst:
-                if not self.bar:
-                    print(
-                        f'{self.comment} {self.package} ALREADY INSTALLED             ')
-                if self.bar:
-                    tqdm.write(
-                        f'{self.comment} {self.package} ALREADY INSTALLED             ')
-            else:
-                if not self.bar:
-                    print(f'{self.comment} {self.package} DONE             ')
-                if self.bar:
-                    tqdm.write(f'{self.comment} {self.package} DONE             ')
-            try:
-                os.remove(f'INSTALL_DONE{self.id}')
-            except Exception:
-                pass
-            try:
-                os.remove(f'INSTALL_ERROR{self.id}')
-            except Exception:
-                pass
-            try:
-                os.remove(f'INSTALL_ALINST{self.id}')
-            except Exception:
-                pass
-
-
-    def choco_install(*packages: str):
-        """
-        The choco_install function installs a list of packages using Chocolatey.
-        It returns the number of packages successfully installed and the number that were already installed.
-
-        :param *packages: str: Pass a variable number of arguments to the function
-        :return: A tuple of two integers
-        """
-
-        alinst_number = 0
-        inst_number = 0
-        for package in packages:
-            version = ''
-            if len(pack := package.split(' --version ')) %3E 1:
-                version = pack[1]
-                package = pack[0]
-            with open('choco_output', 'w') as file:
-                carousel = installing_carousel(package)
-                Thread(target=carousel.start()).start()
-                Thread(target=choco_check, args=(package, carousel)).start()
-                subprocess.run(['choco', 'install', package,
-                               version, '-y'], stdout=file, text=True)
-            with open('choco_output', 'r') as file:
-                alinst = False
-                for line, content in enumerate(file.readlines()):
-                    if 'already installed.' in content and package in content:
-                        carousel.stop('ali')
-                        alinst = True
-                        alinst_number += 1
-                        break
-            try:
-                open('choco_end', 'x')
-            except Exception:
-                pass
-            if not alinst:
-                carousel.stop()
-                inst_number += 1
-            sleep(2)
-        return (inst_number, alinst_number)
-
-    def choco_check(module: str, carousel: installing_carousel) -%3E None:
-        """
-        The choco_check function checks if chocolatey is installed and prompts the user to continue.
-        It also checks if the user is an admin, and confirms that they want to run as non-admin.
-
-        :param module: str: Determine which module is being checked for
-        :return: True when chocolatey is installed, and false when it is not
-        """
-        admin: bool = True
-        adminline = -1
-        cont = False
-        contline = -1
-        ffmpeg_conf = False
-        ffmpegline = -1
-        ffmpeg_confline = -1
-        sleep(2)
-        while os.path.isfile('choco_output'):
-            sleep(0.1)
-            for line, content in enumerate(open('choco_output', 'r').readlines()):
-                if 'WARNING: \'choco\' was found at' in content and module == 'chocolatey':
-                    return True
-                if 'Ensuring chocolatey.nupkg is in the lib folder' in content and module == 'chocolatey':
-                    return False
-                if 'Chocolatey detected you are not running' in content and admin:
-                    if adminline == line:
-                        pass
-                    else:
-                        admin = False
-                        adminline = line
-                if 'Do you want to continue' in content and not admin:
-                    if contline == line:
-                        pass
-                    else:
-                        cont = True
-                        contline = line
-                if 'ffmpeg package files install completed. Performing other installation steps.' in content and module == 'ffmpeg':
-                    if ffmpegline == line:
-                        pass
-                    else:
-                        ffmpeg_conf = True
-                        ffmpegline = line
-                if 'Do you want to run the script' in content and module == 'ffmpeg':
-                    if ffmpeg_confline == line:
-                        pass
-                    else:
-                        cont = True
-                        ffmpeg_confline = line
-            if not admin or ffmpeg_conf or cont:
-                carousel.pause()
-                sleep(0.25)
-                carousel.unpause()
-            if not admin:
-                pg.press('y')
-                admin = True
-            if ffmpeg_conf:
-                pg.press('a')
-                ffmpeg_conf = False
-            if cont or ffmpeg_conf:
-                pg.press('enter')
-                cont = False
-                ffmpeg_conf = False
-            if os.path.isfile('choco_end'):
-                os.remove('choco_end')
-                break
-
-    from threading import Thread
-    if __name__ == '__main__':
-        print_module('Thread from threading')
-    import pyautogui as pg
-    if __name__ == '__main__':
-        print_module('pyautogui')
-        if args.restart is None:
-            pg.keyDown('alt')
-            pg.press('tab')
-            pg.keyUp('alt')
-            pg.keyDown('alt')
-            pg.press('tab')
-            pg.keyUp('alt')
-        pg.keyDown('win')
-        pg.press('up')
-        pg.keyUp('win')
-    if __name__ == '__main__':
-        if not os.path.isfile("C:/Users/" + os.getlogin() + "/AppData/Local/Zn%C3%A1mE/info.txt") or args.update is None:
-            logger.stay(printnlog('First time setup', toprint=False))
-            if not os.path.isfile('INSTALL_RESTART'):
-                with open('choco.ps1', 'w') as file:
-                    file.write('$InstallDir=\'C:\ProgramData\chocoportable\'\n$env:ChocolateyInstall="$InstallDir"\nSet-ExecutionPolicy Bypass -Scope Process -Force;\niex ((New-Object System.Net.WebClient).DownloadString(\'https://community.chocolatey.org/install.ps1\'))')
-                logger.next(
-                    "Checking if chocolatey is installed if not downloading\n")
-                carousel = installing_carousel('chocolatey')
-                Thread(target=carousel.start()).start()
-                Thread(target=choco_check, args=('chocolatey', carousel)).start()
-                with open('choco_output', 'w') as file:
-                    choco = subprocess.run(
-                        ['powershell.exe', '-file', 'choco.ps1', '--quiet', '--no-verbose'], stdout=file, text=True)
-                with open('choco_output', 'r') as file:
-                    for line in file.readlines():
-
-                        "If system don\'t allow running powershell scripts navigate user to allow it"
-
-                        if 'cannot be loaded because running scripts is disabled on this system' in line:
-                            carousel.stop('e')
-                            logger.stay(
-                                'Run Powershell as administrator and type \'Set-ExecutionPolicy RemoteSigned\' type Y and press \'enter\'')
-                            with open('set_permissions.txt', 'w') as file:
-                                file.write(
-                                    'Run Powershell as administrator and type following code press \'enter\' type Y and press \'enter\'\n\nSet-ExecutionPolicy RemoteSigned')
-                            os.system("notepad.exe set_permissions.txt")
-                            input('Enter to continue ...')
-                            os.remove('set_permissions.txt')
-                            with open('choco_output', 'w') as file:
-                                choco = subprocess.run(
-                                    ['powershell.exe', '-file', 'choco.ps1', '--quiet', '--no-verbose'], stdout=file, text=True)
-                open('choco_end', 'x')
-                carousel.stop()
-                logger.prev('')
-                sleep(1)
-
-                def isUserAdmin():
-                    """
-                    The isUserAdmin function checks to see if the user running this script is an admin.
-                    This is for Windows only.
-                    :return: A boolean value
-                    """
-                    if os.name == 'nt':
-                        import ctypes
-                        # WARNING: requires Windows XP SP2 or higher!
-                        try:
-                            return ctypes.windll.shell32.IsUserAnAdmin()
-                        except:
-                            traceback.print_exc()
-                            print("Admin check failed, assuming not an admin.")
-                            return False
-                    elif os.name == 'posix':
-                        # Check for root on Posix
-                        return os.getuid() == 0
-                    else:
-                        raise RuntimeError(
-                            "Unsupported operating system for this module: %s" % (os.name,))
-
-                def runAsAdmin(cmdLine=None, wait=True):
-                    """
-                    The runAsAdmin function is a simple function that will run your python script as the Administrator.
-                    This function will attempt to do the following:
-                    :param cmdLine: Pass arguments to the executable
-                    :param wait: Determine whether the function should wait for the process to finish or not
-                    :return: The process handle of the elevated process
-                    """
-                    if os.name != 'nt':
-                        raise RuntimeError(
-                            "This function is only implemented on Windows.")
-
-                    import win32api
-                    import win32con
-                    import win32event
-                    import win32process
-                    from win32com.shell.shell import ShellExecuteEx  # type: ignore
-                    from win32com.shell import shellcon  # type: ignore
-
-                    python_exe = sys.executable
-
-                    if cmdLine is None:
-                        cmdLine = [python_exe] + sys.argv
-                    elif type(cmdLine) not in (ctypes.TupleType, ctypes.ListType):
-                        raise ValueError("cmdLine is not a sequence.")
-                    cmd = '"%s"' % (cmdLine[0],)
-                    params = " ".join(['"%s"' % (x,) for x in cmdLine[1:]])
-                    cmdDir = ''
-                    showCmd = win32con.SW_SHOWNORMAL
-                    lpVerb = 'runas'
-                    procInfo = ShellExecuteEx(nShow=showCmd,
-                                              fMask=shellcon.SEE_MASK_NOCLOSEPROCESS,
-                                              lpVerb=lpVerb,
-                                              lpFile=cmd,
-                                              lpParameters=params)
-                    if wait:
-                        procHandle = procInfo['hProcess']
-                        obj = win32event.WaitForSingleObject(
-                            procHandle, win32event.INFINITE)
-                        rc = win32process.GetExitCodeProcess(procHandle)
-                    else:
-                        rc = None
-                    return rc
-
-                def checkAdmin():
-                    """
-                    The checkAdmin function checks if the user is an admin. If not, it will run the program as an admin.
-                    :return: 0 if the user is an admin, and returns 1 if the user is not an admin
-                    :doc-author: Trelent
-                    """
-                    rc = 0
-                    if not isUserAdmin():
-                        print("You're not an admin.",
-                              os.getpid(), "params: ", sys.argv)
-                        rc = runAsAdmin()
-                    else:
-                        print("You are an admin!", os.getpid(),
-                              "params: ", sys.argv)
-                        rc = 0
-                    return rc
-
-                os.remove(f"crash_dump-{datelog}.txt")
-                open('INSTALL', 'x')
-                open('INSTALL_RESTART', 'x')
-                os.remove('choco.ps1')
-                os.remove('choco_output')
-                sleep(1)
-                checkAdmin()
-                sys.exit(0)
-            if os.path.isfile('INSTALL'):
-                os.remove('INSTALL')
-
-                "Downloading dependencies using chocolatey"
-
-                choco_packages: list[str] = [
-                    'ffmpeg --version 5.1.2', 'vlc --version 3.0.18', 'vcredist2015 --version 14.0.24215.20170201', 'grep --version 3.7']
-
-                "inst_number is number of installed packages; alinst_number is number of already installed"
-
-                inst_number, alinst_number = choco_install(*choco_packages)
-                if inst_number == 0:
-                    pass
-                else:
-                    logger.stay("Restarting program ...")
-                    sleep(1)
-                    subprocess.check_output(
-                        'start edupage.py --language ' + args.language, shell=True)
-                    os.remove(f"crash_dump-{datelog}.txt")
-                os.remove('choco_output')
-                try:
-                    os.remove('choco_end')
-                except Exception:
-                    pass
-                if inst_number != 0:
-                    sys.exit(0
+from threading import Thread
+    if __name__ == '__main__':
+        print_module('Thread from threading')
+    import pyautogui as pg
+    if __name__ == '__main__':
+        print_module('pyautogui')
+        if args.restart is None:
+            pg.keyDown('alt')
+            pg.press('tab')
+            pg.keyUp('alt')
+            pg.keyDown('alt')
+            pg.press('tab')
+            pg.keyUp('alt')
+        pg.keyDown('win')
+        pg.press('up')
+        pg.keyUp('win')
+    if __name__ == '__main__':
+        if not os.path.isfile("C:/Users/" + os.getlogin() + "/AppData/Local/Zn%C3%A1mE/info.txt") or args.update is None:
+            logger.stay(printnlog('First time setup', toprint=False))
+            if not os.path.isfile('INSTALL_RESTART'):
+                from essentials.app_alternations import install_choco
+                install_choco(logger)
+            if os.path.isfile('INSTALL'):
+                from essentials.app_alternations import install_packages
+                install_packages(
 )%0A  
@@ -16448,24 +16448,34 @@
 ternet_check
+, download
 %0A    if __na
@@ -16517,33 +16517,24 @@
 t_check(args
-, datelog
 )%0A        lo
@@ -16754,110 +16754,8 @@
 e()%0A
-    from pathlib import Path
-    if __name__ == '__main__':
-        print_module('Path from pathlib')
-
     
@@ -16989,90 +16989,8 @@
 e()%0A
-    import semantic_version
-    if __name__ == '__main__':
-        print_module()
-
     
@@ -17278,78 +17278,8 @@
 e()%0A
-    import glob
-    if __name__ == '__main__':
-        print_module()
-
     
@@ -17500,76 +17500,8 @@
 e()%0A
-    import re
-    if __name__ == '__main__':
-        print_module()
-
     
@@ -18253,1192 +18253,8 @@
 ')%0A%0A
-    def download(url: str, fname: str, chunk_size: int = 1024) -%3E bool:
-        """
-        "Download a file from a URL to a local file."
-
-        The first line is the function's signature. It's a single line of code that tells you everything
-        you need to know about the function
-
-        :param url: The URL of the file to download
-        :type url: str
-        :param fname: The name of the file to be downloaded
-        :type fname: str
-        :param chunk_size: The size of the chunks to download, defaults to 1024 (optional)
-        """
-        try:
-            resp = requests.get(url, stream=True)
-            total: int = int(resp.headers.get('content-length', 0))
-            with open(fname, 'wb') as file, tqdm(
-                desc=fname,
-                total=total,
-                unit='iB',
-                unit_scale=True,
-                unit_divisor=1024,
-            ) as bar:
-                for data in resp.iter_content(chunk_size=chunk_size):
-                    size = file.write(data)
-                    bar.update(size)
-        except ConnectionError:
-            logging.warning("Connection error")
-            return False
-        return True
-
-
     
@@ -18786,16 +18786,116 @@
 size[1])
+
+        with open('.env', 'a') as dotenv:
+            dotenv.write(f'SCREENSIZE={str(screensize)}')
 %0A%0A      
@@ -21660,9698 +21660,159 @@
     
-try:
-                url = 'https://raw.githubusercontent.com/GrenManSK/ZnamE/main/version'
-                page = requests.get(url)
-                verzia = open('version', 'r')
-                if semantic_version.Version(page.text[1:]) %3C= semantic_version.Version(verzia.read()[1:]):
-                    logger.next(
-                        printnlog('You have the latest version', toprint=False))
-                    logger.prev('')
-                else:
-                    if args.language == "SK":
-                        printnlog(
-                            "Bola n%C3%A1jden%C3%A1 nov%C3%A1 aktualizacia: " + page.text)
-                    elif args.language == "EN":
-                        printnlog("Newer version was found: " + page.text)
-                    elif args.language == "JP":
-                        printnlog("%E6%96%B0%E3%81%97%E3%81%84%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3%E3%81%8C%E8%A6%8B%E3%81%A4%E3%81%8B%E3%82%8A%E3%81%BE%E3%81%97%E3%81%9F: " + page.text)
-                    verzia.close()
-                    sleep(0.5)
-                    url = 'https://api.github.com/repos/GrenManSK/ZnamE/zipball/main'
-                    r = requests.get(url)
-                    filename = "new.zip"
-                    with open(filename, 'wb') as output_file:
-                        download(url, 'new.zip')
-                    with zipfile.ZipFile("new.zip", mode='r') as zip:
-                        if args.language == "SK":
-                            for member in tqdm(iterable=zip.namelist(), total=len(zip.namelist()), desc='Rozba%C4%BEujem '):
-                                try:
-                                    zip.extract(member)
-                                    tqdm.write(
-                                        f"{os.path.basename(member)}(" + str(os.path.getsize(member)) + "KB)")
-                                except zipfile.error as e:
-                                    pass
-                        elif args.language == "EN":
-                            for member in tqdm(iterable=zip.namelist(), total=len(zip.namelist()), desc='Extracting '):
-                                try:
-                                    zip.extract(member)
-                                    tqdm.write(
-                                        f"{os.path.basename(member)}(" + str(os.path.getsize(member)) + "KB)")
-                                except zipfile.error as e:
-                                    pass
-                        elif args.language == "JP":
-                            for member in tqdm(iterable=zip.namelist(), total=len(zip.namelist()), desc='%E6%8A%BD%E5%87%BA%E4%B8%AD '):
-                                try:
-                                    zip.extract(member)
-                                    tqdm.write(
-                                        f"{os.path.basename(member)}(" + str(os.path.getsize(member)) + "KB)")
-                                except zipfile.error as e:
-                                    pass
-                        zip.close()
-                    os.remove("new.zip")
-                    directory = None
-                    for path, currentDirectory, files in os.walk(Path.cwd()):
-                        for directory1 in currentDirectory:
-                            if directory1.startswith("GrenManSK-ZnamE-"):
-                                printnlog(directory1)
-                                directory = directory1
-                    if directory is None:
-
-                        "If program fails to download update refer user to website"
-
-                        if args.language == "SK":
-                            printnlog(
-                                "CHYBA STAHOVANIA\nStiahnete manu%C3%A1lne nov%C5%A1iu verziu z\n'https://github.com/GrenManSK/ZnamE'")
-                        elif args.language == "EN":
-                            printnlog(
-                                "DOWNLOADING ERROR\nManually download newer version from\n'https://github.com/GrenManSK/ZnamE'")
-                        elif args.language == "JP":
-                            printnlog(
-                                "%E3%83%80%E3%82%A6%E3%83%B3%E3%83%AD%E3%83%BC%E3%83%89 %E3%82%A8%E3%83%A9%E3%83%BC\n'https://github.com/GrenManSK/ZnamE' %E3%81%8B%E3%82%89%E6%96%B0%E3%81%97%E3%81%84%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3%E3%82%92%E6%89%8B%E5%8B%95%E3%81%A7%E3%83%80%E3%82%A6%E3%83%B3%E3%83%AD%E3%83%BC%E3%83%89%E3%81%97%E3%81%A6%E3%81%8F%E3%81%A0%E3%81%95%E3%81%84")
-                        sleep(2)
-                        input()
-                        sys.exit(1)
-                    os.mkdir('old')
-                    shutil.move('data.xp2', 'old/data.xp2')
-                    shutil.move('help.txt', 'old/help.txt')
-                    shutil.move('LICENSE', 'old/LICENSE')
-                    shutil.move('README.md', 'old/README.md')
-                    shutil.move('version', 'old/version')
-                    shutil.copyfile('config.yml', 'config_old.yml')
-                    sleep(0.5)
-                    shutil.move(directory + "/data.xp2", 'data.xp2')
-                    shutil.move(directory + "/help.txt", 'help.txt')
-                    shutil.move(directory + "/LICENSE", 'LICENSE')
-                    shutil.move(directory + "/README.md", 'README.md')
-                    shutil.move(directory + "/version", 'version')
-                    shutil.move(directory + "/config.yml", 'config.yml')
-                    crupdate = open("update.py", "w")
-                    crupdate.write(updateapp)
-                    crupdate.close()
-                    if args.endf is None:
-                        subprocess.call(sys.executable + ' update.py ' + directory +
-                                        ' -lang ' + args.language + ' -endf', shell=True)
-                    else:
-                        subprocess.call(sys.executable + ' update.py ' +
-                                        directory + ' -lang ' + args.language, shell=True)
-                    sleep(0.1)
-                    os.remove('crash_dump-' + datelog + '.txt')
-                    try:
-                        os.remove('choco_end')
-                    except Exception:
-                        pass
-                    try:
-                        os.remove('INSTALL')
-                    except Exception:
-                        pass
-                    try:
-                        os.remove('INSTALL_RESTART')
-                    except Exception:
-                        pass
-                    sys.exit(0)
-            except requests.ConnectionError:  # type: ignore
-                line_number: int = get_line_number()
-                pass
-
-        verzia.close()
-
-    def getWindow() -%3E bool:
-        """
-        The getWindow function is used to find the window of Zn%C3%A1m%C3%BD (the game) and activate it.
-        It also checks if the file 'banner.png' exists in the assets folder.
-
-        :return: If error occured
-        """
-        global exit
-        dummy = None
-        cv2.namedWindow('frame2', cv2.WND_PROP_FULLSCREEN)
-        cv2.setWindowProperty(
-            'frame2', cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)
-        test: str = "assets/banner.png"
-        for file in glob.glob(test):
-            dummy = cv2.imread(file)
-        try:
-            cv2.imshow("Image", dummy)
-        except cv2.error:
-            error_get(cv2.error('File is corrupt (probably \'banner.png\')'), [
-                      get_line_number()])
-            return True
-        cv2.waitKey(1)
-        sleep(0.1)
-        cv2.destroyWindow("Image")
-        if args.test is not None:
-            try:
-                window = pygetwindow.getWindowsWithTitle('Zn%C3%A1mE')[0]
-                window.activate()
-                return False
-            except IndexError:
-                error_get(IndexError(
-                    'Possible solution; run in cmd or python aplication not ide or put arguments \'--test\''), [get_line_number()])
-                return True
-        return False
-
-    if __name__ == '__main__':
-        logger.next(printnlog('Function: getWindow', toprint=False))
-
-    def getImg(imgSrc: str, name: str, x=None, y=None, width=None, length=None) -%3E None:
-        """
-        The getImg function displays an image from the source. If x, y, width, and length are specified, then the image will be displayed at those coordinates with the specified width and length. Otherwise, the image will be displayed at the default coordinates and default width and length.
-
-        :param imgSrc: str: Specify the source of the image
-        :param name: str: Name the window
-        :param x: Set the x coordinate of the window
-        :param y: Specify the y coordinate of the window
-        :param width: Set the width of the window
-        :param length: Set the length of the window
-        :return: The image that is displayed
-        """
-        path: str = imgSrc
-        for file in glob.glob(path):
-            global dummy
-            dummy = cv2.imread(file)
-            cv2.imshow(name, dummy)
-            if x is not None and y is not None and width is not None and length is not None:
-                appname: str = name
-                xpos: int = x
-                ypos: int = y
-                if width is None:
-                    width = int((screensize[0]/10)*9)
-                if length is None:
-                    length = int((screensize[1]/10)*9)
-
-                def enumHandler(hwnd, lParam):
-                    if win32gui.IsWindowVisible(hwnd):  # type: ignore
-                        # type: ignore
-                        if appname in win32gui.GetWindowText(hwnd):
-                            win32gui.MoveWindow(
-                                hwnd, xpos, ypos, width, length, True)  # type: ignore
-                win32gui.EnumWindows(enumHandler, None)  # type: ignore
-            k = cv2.waitKey(33)
-            cv2.setWindowProperty(
-                name, cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)
-            if k == 27:
-                break
-            elif k == -1:
-                continue
-            else:
-                print(k)
-                cv2.destroyAllWindows()
+from essentials.app_alternations import update_app
+            update_app(args, logger)
+
+    from essentials.system_operations import getWindow, getImg
 %0A%0A  
@@ -34426,32 +34426,100 @@
  toprint=False))
+
+        logger.next(printnlog('Defining functions', toprint=False))
 %0A%0A    def get_si
@@ -56802,16 +56802,17 @@
 seclick 
+ 
 # type: 
@@ -58699,16 +58699,17 @@
 admusic 
+ 
 # type: 
@@ -58707,32 +58707,100 @@
  # type: ignore%0A
+        from essentials.app_alternations import installing_carousel
+
         typewrit
@@ -59153,16 +59153,29 @@
 arousel(
+
+            
 '', comm
@@ -60398,33 +60398,16 @@
 False))%0A
-        
-        
 %0A    def
@@ -61084,20 +61084,16 @@
 _player%0A
-    
 %0A    def
@@ -62039,25 +62039,16 @@
 rn exit%0A
-    
-    
 %0A    def
@@ -63318,24 +63318,16 @@
    pass%0A
-        
 %0A    def
@@ -63845,25 +63845,16 @@
 r.stop()
-
-        
 %0A%0A    de
@@ -65177,28 +65177,16 @@
 = False%0A
-            
 %0A       
@@ -67136,32 +67136,36 @@
 ool = getWindow(
+args
 )%0A            if
@@ -69726,33 +69726,24 @@
 t_check(args
-, datelog
 )%0A          
@@ -70666,16 +70666,49 @@
 entials(
+
+                                
 args, lo
@@ -77655,32 +77655,36 @@
       getWindow(
+args
 )%0A              
@@ -80191,32 +80191,36 @@
       getWindow(
+args
 )%0A              
@@ -133789,16 +133789,53 @@
  = code(
+
+                                    
 find(dec
@@ -133958,16 +133958,20 @@
 tWindow(
+args
 )%0A      
@@ -143292,16 +143292,17 @@
 rch.py',
+ 
 'mouse.p
@@ -143331,16 +143331,17 @@
 een.py',
+ 
 'login.p
@@ -153022,32 +153022,182 @@
 s.remove('END')%0A
+                        try:
+                            os.remove('.env')
+                        except Exception:
+                            pass
+
                 
@@ -158476,32 +158476,182 @@
 s.remove('END')%0A
+                        try:
+                            os.remove('.env')
+                        except Exception:
+                            pass
+
                 


essentials/arguments.py
@@ -9,16 +9,282 @@
 rgparse%0A
+import sys
+from .internet import get_line_number
+from .writing import printnlog, typewriter
+from .exceptions import argEnviromentError, argInactiveLimitError, argIntroError, argMusicError, argWaifuError, argNekoError, argGameError
+from .exceptions import error_get
+
+
 %0Adef arg
@@ -3543,20 +3543,5766 @@
 anguage, UNSPECIFIED
+
+
+
+def check_correctness(args, config, logger, music, set_config):
+    hexnumber: list[str] = ['0', '1', '2', '3', '4', '5', '6',
+                            '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']
+    logger.stay(printnlog("Checking config correctness", toprint=False))
+    if not config['basic info']['enviroment'].split(' ')[0][0] in hexnumber:
+        error_get(ExceptionGroup('', [argEnviromentError('Wrong choice \'basic info\' =%3E enviroment first character'), ValueError(
+            f'Not allowed character %7C Allowed: {hexnumber}')]), [get_line_number()])
+        sys.exit(1)
+    elif not config['basic info']['enviroment'].split(' ')[0][1] in hexnumber:
+        error_get(ExceptionGroup('', [argEnviromentError('Wrong choice \'basic info\' =%3E enviroment second character'), ValueError(
+            f'Not allowed character %7C Allowed: {hexnumber}')]), [get_line_number()])
+        sys.exit(1)
+    else:
+        printnlog('basic info =%3E enviroment')
+    try:
+        int(config['basic info']['inactivelimit'])
+        printnlog('basic info =%3E inactivelimit')
+    except ValueError:
+        error_get(ExceptionGroup('', [argInactiveLimitError(
+            'Wrong choice in \'basic info\' =%3E inactivelimit'), ValueError('take only numbers')]), [get_line_number()])
+        sys.exit(1)
+    if not config['basic info']['intro'] in [True, False]:
+        error_get(ExceptionGroup('', [argIntroError('Wrong choice in \'basic info\' =%3E intro'), ValueError(
+            'Only \'True\' or \'False\'')]), [get_line_number()])
+        sys.exit(1)
+    else:
+        printnlog('basic info =%3E intro')
+    if config['basic info']['music'].split(' ')[0] == 'enable':
+        args.music = config['basic info']['musicnumber']
+        printnlog('basic info =%3E music')
+    elif config['basic info']['music'].split(' ')[0] == 'disable':
+        printnlog('basic info =%3E music')
+        pass
+    else:
+        error_get(ExceptionGroup('', [argMusicError('Wrong choice in \'basic info\' =%3E music'), ValueError(
+            'Only \'enable\' or \'disable\'')]), [get_line_number()])
+        sys.exit(1)
+    if not config['waifu settings']['type'].split(' ')[0] in ['sfw', 'nsfw']:
+        error_get(ExceptionGroup('', [argWaifuError('Wrong choice in \'waifu settings\' =%3E type'), ValueError(
+            'Only \'sfw\' or \'nsfw\'')]), [get_line_number()])
+        sys.exit(1)
+    else:
+        printnlog('waifu settings =%3E type')
+    if config['waifu settings']['type'] == 'sfw':
+        category: list[str] = ["waifu", "neko", "shinobu", "megumin", "bully", "cuddle", "cry", "hug", "awoo", "kiss", "lick", "pat", "smug", "bonk", "yeet",
+                               "blush", "smile", "wave", "highfive", "handhold", "nom", "bite", "glomp", "slap", "kill", "kick", "happy", "wink", "poke", "dance", "cringe"]
+        if not config['waifu settings']['category'].split(' ')[0] in category:
+            error_get(ExceptionGroup('', [argWaifuError('Wrong choice in \'waifu settings\' =%3E category'), ValueError(
+                'Use \'waifu\' and see option in setup function')]), [get_line_number()])
+            sys.exit(1)
+        else:
+            printnlog('waifu settings =%3E category')
+    elif config['waifu settings']['type'] == 'nsfw':
+        category: list[str] = ['waifu', 'neko', 'trap', 'blowjob']
+        if not config['waifu settings']['category'].split(' ')[0] in category:
+            error_get(ExceptionGroup('', [argWaifuError('Wrong choice in \'waifu settings\' =%3E category'), ValueError(
+                'Use \'waifu\' and see option in setup function')]), [get_line_number()])
+            sys.exit(1)
+        else:
+            printnlog('waifu settings =%3E category')
+    server: list[str] = ['nekos.best', 'waifu.pics', 'kyoko', 'nekos_api']
+    if not config['neko settings']['server'] in server:
+        error_get(ExceptionGroup('', [argNekoError('Wrong choice in \'neko settings\' =%3E server'), ValueError(
+            f'Only take {str(server)}')]), [get_line_number()])
+        sys.exit(1)
+    else:
+        printnlog('neko settings =%3E server')
+    try:
+        int(config['game settings']['goal_score'])
+    except ValueError:
+        error_get(ExceptionGroup('', [argGameError('Wrong choice in \'game settings\' =%3E goal_score'), ValueError(
+            'take only numbers')]), [get_line_number()])
+        sys.exit(1)
+    try:
+        if 10 %3C= int(config['game settings']['goal_score']):
+            printnlog('game settings =%3E goal_score')
+        else:
+            raise ValueError
+    except ValueError:
+        error_get(ExceptionGroup('', [argGameError(
+            'Wrong choice in \'game settings\' =%3E goal_score'), ValueError('minimum is 10')]), [get_line_number()])
+        sys.exit(1)
+    try:
+        float(config['game settings']['computer_power'])
+        printnlog('game settings =%3E computer_power')
+    except ValueError:
+        error_get(ExceptionGroup('', [argGameError('Wrong choice in \'game settings\' =%3E computer_power'), ValueError(
+            'take only numbers')]), [get_line_number()])
+        sys.exit(1)
+    if config['basic info']['music'] == 'enable':
+        musiclimittext: bool = False
+        lenmusic = len(music)
+        configlenmusic = int(config['basic info']['musicnumber'])
+        while lenmusic %3C configlenmusic:
+            if not musiclimittext:
+                typewriter(printnlog('basic info =%3E musicnumber; you have exceeded the limit by ' +
+                                     str(int(config['basic info']['musicnumber']) - len(music)), toprint=False))
+                musiclimittext: bool = True
+            set_config('basic info', 'musicnumber', int(args.music)-1)
+            configlenmusic = int(config['basic info']['musicnumber'])
+            args.music = int(args.music) - 1
+


essentials/file_operations.py
@@ -947,33 +947,24 @@
         log(
-datelog, 
 f"{os.path.b
@@ -975,32 +975,56 @@
 ame(member)}(" +
+
+                       
  str(os.path.get
@@ -1476,17 +1476,8 @@
 log,
- datelog,
  f"{
@@ -1975,33 +1975,24 @@
         log(
-datelog, 
 f"{os.path.b
@@ -2220,25 +2220,16 @@
 intnlog(
-datelog, 
 'Hotovo\
@@ -2290,25 +2290,16 @@
 intnlog(
-datelog, 
 "Rozba%C4%BEu
@@ -2397,25 +2397,16 @@
 intnlog(
-datelog, 
 'Done\n'
@@ -2465,25 +2465,16 @@
 intnlog(
-datelog, 
 "Unpacki
@@ -2572,25 +2572,16 @@
 intnlog(
-datelog, 
 '%E7%B5%82%E3%82%8F%E3%82%8A\n',
@@ -2626,25 +2626,16 @@
 intnlog(
-datelog, 
 "2 %E7%95%AA%E7%9B%AE%E3%81%AE%E9%83%A8%E5%88%86
@@ -3768,33 +3768,24 @@
   printnlog(
-datelog, 
 os.path.join
@@ -4026,25 +4026,16 @@
 intnlog(
-datelog, 
 os.path.
@@ -4313,25 +4313,16 @@
 intnlog(
-datelog, 
 i)%0A     
@@ -4528,25 +4528,16 @@
 intnlog(
-datelog, 
 '\nZa%C4%8D%C3%ADn
@@ -4631,25 +4631,16 @@
 intnlog(
-datelog, 
 '\nStart
@@ -4735,25 +4735,16 @@
 intnlog(
-datelog, 
 "\n%E6%8A%BD%E5%87%BA%E9%96%8B%E5%A7%8B\
@@ -5157,25 +5157,16 @@
 intnlog(
-datelog, 
 '\nHotov
@@ -5229,25 +5229,16 @@
 intnlog(
-datelog, 
 '\nDone\
@@ -5299,25 +5299,16 @@
 intnlog(
-datelog, 
 '\n%E5%AE%8C%E4%BA%86\n'


essentials/internet.py
@@ -117,914 +117,86 @@
 ead%0A
-import inspect
-
-
-def get_line_number(goback: int = 0, relative_frame: int = 1) -%3E int:
-    """
-    The get_line_number function returns the line number of the caller.
-
-        The get_line_number function is a helper function that returns the line number of 
-        where it was called from. This can be useful for debugging purposes, or to help 
-        identify where an error occurred in your code. It also allows you to go back a few lines if needed, which can be helpful when using this function inside loops and other functions that may have multiple calls on one line (such as list comprehensions).
-
-    :param goback: int: Go back a certain number of lines in the stackconfig.
-    :param relative_frame: int: Specify the frame in the stack to get the 
+from tqdm import tqdm
+import logging
+from .system_info import get_
 line
- 
+_
 number
- from
-    :return: The line number of the function call
-    """
-    return int(inspect.stack()[relative_frame][0].f_lineno)-int(goback)
+
+
 %0A%0Ade
@@ -210,25 +210,16 @@
 net(args
-, datelog
 ):%0A    n
@@ -940,16 +940,17 @@
  break%0A%0A
+
+
 def inte
@@ -964,25 +964,16 @@
 eck(args
-, datelog
 ) -%3E Non
@@ -1105,16 +1105,8 @@
 rgs,
- datelog
 )).s
@@ -1832,8 +1832,1082 @@
 .exit(1)
+
+
+
+def download(url: str, fname: str, chunk_size: int = 1024) -%3E bool:
+    """
+    "Download a file from a URL to a local file."
+
+    The first line is the function's signature. It's a single line of code that tells you everything
+    you need to know about the function
+
+    :param url: The URL of the file to download
+    :type url: str
+    :param fname: The name of the file to be downloaded
+    :type fname: str
+    :param chunk_size: The size of the chunks to download, defaults to 1024 (optional)
+    """
+    try:
+        resp = requests.get(url, stream=True)
+        total: int = int(resp.headers.get('content-length', 0))
+        with open(fname, 'wb') as file, tqdm(
+            desc=fname,
+            total=total,
+            unit='iB',
+            unit_scale=True,
+            unit_divisor=1024,
+        ) as bar:
+            for data in resp.iter_content(chunk_size=chunk_size):
+                size = file.write(data)
+                bar.update(size)
+    except ConnectionError:
+        logging.warning("Connection error")
+        return False
+    return True
+


essentials/system_info.py
@@ -98,16 +98,30 @@
 ort sys%0A
+from tabulate 
 import t
@@ -190,16 +190,31 @@
 intnlog%0A
+import inspect
+
 %0A%0Adef sy
@@ -253,17 +253,8 @@
 rzia
-, datelog
 ):%0A 
@@ -507,25 +507,16 @@
 to_info(
-datelog, 
 verzia.r
@@ -614,25 +614,16 @@
 intnlog(
-datelog, 
 'Getting
@@ -684,25 +684,16 @@
 to_info(
-datelog, 
 'Resolut
@@ -2391,25 +2391,16 @@
 to_info(
-datelog, 
 os_info,
@@ -2527,25 +2527,16 @@
 to_info(
-datelog, 
 'OS Name
@@ -2608,25 +2608,16 @@
 to_info(
-datelog, 
 f"Device
@@ -2691,25 +2691,16 @@
 to_info(
-datelog, 
 f"Archit
@@ -2778,25 +2778,16 @@
 to_info(
-datelog, 
 f"Proces
@@ -2855,25 +2855,16 @@
 to_info(
-datelog, 
 'CPU: {0
@@ -2935,33 +2935,24 @@
 tay(to_info(
-datelog, 
 "="*40 + "CP
@@ -3018,25 +3018,16 @@
 to_info(
-datelog, 
 f"CPU ar
@@ -3101,25 +3101,16 @@
 to_info(
-datelog, 
 "Physica
@@ -3215,25 +3215,16 @@
 to_info(
-datelog, 
 "Total c
@@ -3334,25 +3334,16 @@
 to_info(
-datelog, 
 f"Max Fr
@@ -3423,25 +3423,16 @@
 to_info(
-datelog, 
 f"Min Fr
@@ -3512,25 +3512,16 @@
 to_info(
-datelog, 
 f"Curren
@@ -3600,25 +3600,16 @@
 to_info(
-datelog, 
 "CPU Usa
@@ -3756,25 +3756,16 @@
 to_info(
-datelog, 
 f"Core {
@@ -3804,33 +3804,24 @@
 rev(to_info(
-datelog, 
 pc.Win32_Pro
@@ -3878,33 +3878,24 @@
     to_info(
-datelog, 
 f"Total CPU 
@@ -3976,25 +3976,16 @@
 to_info(
-datelog, 
 'RAM: {0
@@ -4055,33 +4055,24 @@
     to_info(
-datelog, 
 "="*40 + "Me
@@ -4144,33 +4144,24 @@
     to_info(
-datelog, 
 f"Total: {ge
@@ -4233,25 +4233,16 @@
 to_info(
-datelog, 
 f"Availa
@@ -4322,33 +4322,24 @@
     to_info(
-datelog, 
 f"Used: {get
@@ -4405,33 +4405,24 @@
     to_info(
-datelog, 
 f"Percentage
@@ -4478,33 +4478,24 @@
 tay(to_info(
-datelog, 
 "="*20 + "SW
@@ -4553,33 +4553,24 @@
     to_info(
-datelog, 
 f"Total: {ge
@@ -4641,25 +4641,16 @@
 to_info(
-datelog, 
 f"Free: 
@@ -4723,25 +4723,16 @@
 to_info(
-datelog, 
 f"Used: 
@@ -4796,25 +4796,16 @@
 to_info(
-datelog, 
 f"Percen
@@ -4868,25 +4868,16 @@
 to_info(
-datelog, 
 'Graphic
@@ -4966,33 +4966,24 @@
     to_info(
-datelog, 
 "="*40 + "GP
@@ -5547,17 +5547,16 @@
      ))%0A
-
-
     logg
@@ -5571,25 +5571,16 @@
 to_info(
-datelog, 
 tabulate
@@ -5636,16 +5636,32 @@
 memory",
+
+               
  "used m
@@ -5687,61 +5687,8 @@
 ry",
-
-                                                    
  "te
@@ -5745,33 +5745,24 @@
 tay(to_info(
-datelog, 
 %0A        f'I
@@ -5858,25 +5858,16 @@
 to_info(
-datelog, 
 %0A       
@@ -5983,33 +5983,24 @@
     to_info(
-datelog, 
 "="*40 + "Di
@@ -6065,25 +6065,16 @@
 to_info(
-datelog, 
 "Partiti
@@ -6196,33 +6196,24 @@
     to_info(
-datelog, 
 f"=== Device
@@ -6292,33 +6292,24 @@
     to_info(
-datelog, 
 f"  Mountpoi
@@ -6390,33 +6390,24 @@
     to_info(
-datelog, 
 f"  File sys
@@ -6626,33 +6626,24 @@
     to_info(
-datelog, 
 f"  Total Si
@@ -6736,33 +6736,24 @@
     to_info(
-datelog, 
 f"  Used: {g
@@ -6839,33 +6839,24 @@
     to_info(
-datelog, 
 f"  Free: {g
@@ -6942,33 +6942,24 @@
     to_info(
-datelog, 
 f"  Percenta
@@ -7036,33 +7036,24 @@
     to_info(
-datelog, 
 f"Total read
@@ -7133,33 +7133,24 @@
     to_info(
-datelog, 
 f"Total writ
@@ -7236,25 +7236,16 @@
 to_info(
-datelog, 
 "="*40 +
@@ -7451,25 +7451,16 @@
 to_info(
-datelog, 
 f"=== In
@@ -7623,33 +7623,24 @@
     to_info(
-datelog, 
 f"  IP Addre
@@ -7732,33 +7732,24 @@
     to_info(
-datelog, 
 f"  Netmask:
@@ -7838,33 +7838,24 @@
     to_info(
-datelog, 
 f"  Broadcas
@@ -8018,33 +8018,24 @@
     to_info(
-datelog, 
 f"  MAC Addr
@@ -8128,33 +8128,24 @@
     to_info(
-datelog, 
 f"  Netmask:
@@ -8238,25 +8238,16 @@
 to_info(
-datelog, 
 f"  Broa
@@ -8378,33 +8378,24 @@
     to_info(
-datelog, 
 f"Total Byte
@@ -8484,25 +8484,16 @@
 to_info(
-datelog, 
 f"Total 
@@ -8581,25 +8581,16 @@
 to_info(
-datelog, 
 pc.Win32
@@ -8652,25 +8652,16 @@
 to_info(
-datelog, 
 "User Cu
@@ -8759,17 +8759,8 @@
 log(
-datelog, 
 '\nD
@@ -8763,28 +8763,920 @@
 '\nDONE\n', toprint=False))%0A
+
+
+def get_line_number(goback: int = 0, relative_frame: int = 1) -%3E int:
+    """
+    The get_line_number function returns the line number of the caller.
+
+        The get_line_number function is a helper function that returns the line number of 
+        where it was called from. This can be useful for debugging purposes, or to help 
+        identify where an error occurred in your code. It also allows you to go back a few lines if needed, which can be helpful when using this function inside loops and other functions that may have multiple calls on one line (such as list comprehensions).
+
+    :param goback: int: Go back a certain number of lines in the stackconfig.
+    :param relative_frame: int: Specify the frame in the stack to get the line number from
+    :return: The line number of the function call
+    """
+    return int(inspect.stack()[relative_frame][0].f_lineno)-int(goback)
+


essentials/writing.py
@@ -37,16 +37,67 @@
 t sleep%0A
+from dotenv import load_dotenv
+load_dotenv('.env')
+
 %0A%0Adef pr
@@ -100,33 +100,24 @@
 f printnlog(
-datelog, 
 msg: str, en
@@ -428,32 +428,67 @@
 tional)%0A    """%0A
+    datelog = os.getenv('DATELOG')
+
     with open(f"
@@ -687,25 +687,16 @@
 to_info(
-datelog, 
 msg: str
@@ -1283,32 +1283,67 @@
 d to it%0A    """%0A
+    datelog = os.getenv('DATELOG')
+
     with open(f"
@@ -1733,17 +1733,8 @@
 log(
-datelog, 
 msg:
@@ -1974,24 +1974,59 @@
 al)%0A    """%0A
+    datelog = os.getenv('DATELOG')
+
     with ope
@@ -2764,16 +2764,17 @@
 e(end)%0A%0A
+
+
 def show
@@ -3116,16 +3116,17 @@
   verzia.close()
+
+


uninstall.py
@@ -58,14 +58,77 @@
 om e
-dupage
+ssentials.exceptions import error_get
+    from essentials.system_info
  imp
@@ -150,30 +150,8 @@
 mber
-, error_log, error_get
 %0A%0A%0Ad


version
@@ -23,12 +23,12 @@
 3042
-1.1-alpha+build.20230428.172227
+2.0-alpha+build.20230429.122048


```
